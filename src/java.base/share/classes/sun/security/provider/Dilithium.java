/*
 * Copyright (c) 2024, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the "Classpath" exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.security.provider;

import jdk.internal.vm.annotation.IntrinsicCandidate;
import sun.security.provider.SHA3.SHAKE128;
import sun.security.provider.SHA3.SHAKE256;

import java.util.Arrays;

public class Dilithium {
    private static final int dilithium_q = 8380417;
    private static final int dilithium_n = 256;
    private static final int shake256BlockSize = 136; // the block length for SHAKE256
    private static final int montRBits = 32;
    private static final long montR = 4294967296L; // 1 << montRBits
    private static final int montQ = 8380417;
    private static final int montRSquareModQ = 2365951;
    private static final int montQInvModR = 58728449;
    private static final int montRModQ = 4193792;
    private static final int montDimInverse = 16382; // toMont((dilithium_n)^-1 (mod dilithium_q))
    private static final int[] montZetasForNtt = new int[]{
        25847, -2608894, -518909, 237124, -777960, -876248, 466468, 1826347,
        2353451, -359251, -2091905, 3119733, -2884855, 3111497, 2680103, 2725464,
        1024112, -1079900, 3585928, -549488, -1119584, 2619752, -2108549, -2118186,
        -3859737, -1399561, -3277672, 1757237, -19422, 4010497, 280005, 2706023,
        95776, 3077325, 3530437, -1661693, -3592148, -2537516, 3915439, -3861115,
        -3043716, 3574422, -2867647, 3539968, -300467, 2348700, -539299, -1699267,
        -1643818, 3505694, -3821735, 3507263, -2140649, -1600420, 3699596, 811944,
        531354, 954230, 3881043, 3900724, -2556880, 2071892, -2797779, -3930395,
        -1528703, -3677745, -3041255, -1452451, 3475950, 2176455, -1585221, -1257611,
        1939314, -4083598, -1000202, -3190144, -3157330, -3632928, 126922, 3412210,
        -983419, 2147896, 2715295, -2967645, -3693493, -411027, -2477047, -671102,
        -1228525, -22981, -1308169, -381987, 1349076, 1852771, -1430430, -3343383,
        264944, 508951, 3097992, 44288, -1100098, 904516, 3958618, -3724342,
        -8578, 1653064, -3249728, 2389356, -210977, 759969, -1316856, 189548,
        -3553272, 3159746, -1851402, -2409325, -177440, 1315589, 1341330, 1285669,
        -1584928, -812732, -1439742, -3019102, -3881060, -3628969, 3839961, 2091667,
        3407706, 2316500, 3817976, -3342478, 2244091, -2446433, -3562462, 266997,
        2434439, -1235728, 3513181, -3520352, -3759364, -1197226, -3193378, 900702,
        1859098, 909542, 819034, 495491, -1613174, -43260, -522500, -655327,
        -3122442, 2031748, 3207046, -3556995, -525098, -768622, -3595838, 342297,
        286988, -2437823, 4108315, 3437287, -3342277, 1735879, 203044, 2842341,
        2691481, -2590150, 1265009, 4055324, 1247620, 2486353, 1595974, -3767016,
        1250494, 2635921, -3548272, -2994039, 1869119, 1903435, -1050970, -1333058,
        1237275, -3318210, -1430225, -451100, 1312455, 3306115, -1962642, -1279661,
        1917081, -2546312, -1374803, 1500165, 777191, 2235880, 3406031, -542412,
        -2831860, -1671176, -1846953, -2584293, -3724270, 594136, -3776993, -2013608,
        2432395, 2454455, -164721, 1957272, 3369112, 185531, -1207385, -3183426,
        162844, 1616392, 3014001, 810149, 1652634, -3694233, -1799107, -3038916,
        3523897, 3866901, 269760, 2213111, -975884, 1717735, 472078, -426683,
        1723600, -1803090, 1910376, -1667432, -1104333, -260646, -3833893, -2939036,
        -2235985, -420899, -2286327, 183443, -976891, 1612842, -3545687, -554416,
        3919660, -48306, -1362209, 3937738, 1400424, -846154, 1976782
    };
    private static final int[] montZetasForInverseNtt = new int[]{
        -1976782, 846154, -1400424, -3937738, 1362209, 48306, -3919660, 554416,
        3545687, -1612842, 976891, -183443, 2286327, 420899, 2235985, 2939036,
        3833893, 260646, 1104333, 1667432, -1910376, 1803090, -1723600, 426683,
        -472078, -1717735, 975884, -2213111, -269760, -3866901, -3523897, 3038916,
        1799107, 3694233, -1652634, -810149, -3014001, -1616392, -162844, 3183426,
        1207385, -185531, -3369112, -1957272, 164721, -2454455, -2432395, 2013608,
        3776993, -594136, 3724270, 2584293, 1846953, 1671176, 2831860, 542412,
        -3406031, -2235880, -777191, -1500165, 1374803, 2546312, -1917081, 1279661,
        1962642, -3306115, -1312455, 451100, 1430225, 3318210, -1237275, 1333058,
        1050970, -1903435, -1869119, 2994039, 3548272, -2635921, -1250494, 3767016,
        -1595974, -2486353, -1247620, -4055324, -1265009, 2590150, -2691481, -2842341,
        -203044, -1735879, 3342277, -3437287, -4108315, 2437823, -286988, -342297,
        3595838, 768622, 525098, 3556995, -3207046, -2031748, 3122442, 655327,
        522500, 43260, 1613174, -495491, -819034, -909542, -1859098, -900702,
        3193378, 1197226, 3759364, 3520352, -3513181, 1235728, -2434439, -266997,
        3562462, 2446433, -2244091, 3342478, -3817976, -2316500, -3407706, -2091667,
        -3839961, 3628969, 3881060, 3019102, 1439742, 812732, 1584928, -1285669,
        -1341330, -1315589, 177440, 2409325, 1851402, -3159746, 3553272, -189548,
        1316856, -759969, 210977, -2389356, 3249728, -1653064, 8578, 3724342,
        -3958618, -904516, 1100098, -44288, -3097992, -508951, -264944, 3343383,
        1430430, -1852771, -1349076, 381987, 1308169, 22981, 1228525, 671102,
        2477047, 411027, 3693493, 2967645, -2715295, -2147896, 983419, -3412210,
        -126922, 3632928, 3157330, 3190144, 1000202, 4083598, -1939314, 1257611,
        1585221, -2176455, -3475950, 1452451, 3041255, 3677745, 1528703, 3930395,
        2797779, -2071892, 2556880, -3900724, -3881043, -954230, -531354, -811944,
        -3699596, 1600420, 2140649, -3507263, 3821735, -3505694, 1643818, 1699267,
        539299, -2348700, 300467, -3539968, 2867647, -3574422, 3043716, 3861115,
        -3915439, 2537516, 3592148, 1661693, -3530437, -3077325, -95776, -2706023,
        -280005, -4010497, 19422, -1757237, 3277672, 1399561, 3859737, 2118186,
        2108549, -2619752, 1119584, 549488, -3585928, 1079900, -1024112, -2725464,
        -2680103, -3111497, 2884855, -3119733, 2091905, 359251, -2353451, -1826347,
        -466468, 876248, 777960, -237124, 518909, 2608894, -25847
    };

    private static final int[] montZetasForVectorNtt = new int[]{
        25847, 25847, 25847, 25847, 25847, 25847, 25847, 25847,
        25847, 25847, 25847, 25847, 25847, 25847, 25847, 25847,
        25847, 25847, 25847, 25847, 25847, 25847, 25847, 25847,
        25847, 25847, 25847, 25847, 25847, 25847, 25847, 25847,
        25847, 25847, 25847, 25847, 25847, 25847, 25847, 25847,
        25847, 25847, 25847, 25847, 25847, 25847, 25847, 25847,
        25847, 25847, 25847, 25847, 25847, 25847, 25847, 25847,
        25847, 25847, 25847, 25847, 25847, 25847, 25847, 25847,
        25847, 25847, 25847, 25847, 25847, 25847, 25847, 25847,
        25847, 25847, 25847, 25847, 25847, 25847, 25847, 25847,
        25847, 25847, 25847, 25847, 25847, 25847, 25847, 25847,
        25847, 25847, 25847, 25847, 25847, 25847, 25847, 25847,
        25847, 25847, 25847, 25847, 25847, 25847, 25847, 25847,
        25847, 25847, 25847, 25847, 25847, 25847, 25847, 25847,
        25847, 25847, 25847, 25847, 25847, 25847, 25847, 25847,
        25847, 25847, 25847, 25847, 25847, 25847, 25847, 25847,

        -2608894, -2608894, -2608894, -2608894, -2608894, -2608894, -2608894, -2608894,
        -2608894, -2608894, -2608894, -2608894, -2608894, -2608894, -2608894, -2608894,
        -2608894, -2608894, -2608894, -2608894, -2608894, -2608894, -2608894, -2608894,
        -2608894, -2608894, -2608894, -2608894, -2608894, -2608894, -2608894, -2608894,
        -2608894, -2608894, -2608894, -2608894, -2608894, -2608894, -2608894, -2608894,
        -2608894, -2608894, -2608894, -2608894, -2608894, -2608894, -2608894, -2608894,
        -2608894, -2608894, -2608894, -2608894, -2608894, -2608894, -2608894, -2608894,
        -2608894, -2608894, -2608894, -2608894, -2608894, -2608894, -2608894, -2608894,
        -518909, -518909, -518909, -518909, -518909, -518909, -518909, -518909,
        -518909, -518909, -518909, -518909, -518909, -518909, -518909, -518909,
        -518909, -518909, -518909, -518909, -518909, -518909, -518909, -518909,
        -518909, -518909, -518909, -518909, -518909, -518909, -518909, -518909,
        -518909, -518909, -518909, -518909, -518909, -518909, -518909, -518909,
        -518909, -518909, -518909, -518909, -518909, -518909, -518909, -518909,
        -518909, -518909, -518909, -518909, -518909, -518909, -518909, -518909,
        -518909, -518909, -518909, -518909, -518909, -518909, -518909, -518909,

        237124, 237124, 237124, 237124, 237124, 237124, 237124, 237124,
        237124, 237124, 237124, 237124, 237124, 237124, 237124, 237124,
        237124, 237124, 237124, 237124, 237124, 237124, 237124, 237124,
        237124, 237124, 237124, 237124, 237124, 237124, 237124, 237124,
        -777960, -777960, -777960, -777960, -777960, -777960, -777960, -777960,
        -777960, -777960, -777960, -777960, -777960, -777960, -777960, -777960,
        -777960, -777960, -777960, -777960, -777960, -777960, -777960, -777960,
        -777960, -777960, -777960, -777960, -777960, -777960, -777960, -777960,
        -876248, -876248, -876248, -876248, -876248, -876248, -876248, -876248,
        -876248, -876248, -876248, -876248, -876248, -876248, -876248, -876248,
        -876248, -876248, -876248, -876248, -876248, -876248, -876248, -876248,
        -876248, -876248, -876248, -876248, -876248, -876248, -876248, -876248,
        466468, 466468, 466468, 466468, 466468, 466468, 466468, 466468,
        466468, 466468, 466468, 466468, 466468, 466468, 466468, 466468,
        466468, 466468, 466468, 466468, 466468, 466468, 466468, 466468,
        466468, 466468, 466468, 466468, 466468, 466468, 466468, 466468,

        1826347, 1826347, 1826347, 1826347, 1826347, 1826347, 1826347, 1826347,
        1826347, 1826347, 1826347, 1826347, 1826347, 1826347, 1826347, 1826347,
        2353451, 2353451, 2353451, 2353451, 2353451, 2353451, 2353451, 2353451,
        2353451, 2353451, 2353451, 2353451, 2353451, 2353451, 2353451, 2353451,
        -359251, -359251, -359251, -359251, -359251, -359251, -359251, -359251,
        -359251, -359251, -359251, -359251, -359251, -359251, -359251, -359251,
        -2091905, -2091905, -2091905, -2091905, -2091905, -2091905, -2091905, -2091905,
        -2091905, -2091905, -2091905, -2091905, -2091905, -2091905, -2091905, -2091905,
        3119733, 3119733, 3119733, 3119733, 3119733, 3119733, 3119733, 3119733,
        3119733, 3119733, 3119733, 3119733, 3119733, 3119733, 3119733, 3119733,
        -2884855, -2884855, -2884855, -2884855, -2884855, -2884855, -2884855, -2884855,
        -2884855, -2884855, -2884855, -2884855, -2884855, -2884855, -2884855, -2884855,
        3111497, 3111497, 3111497, 3111497, 3111497, 3111497, 3111497, 3111497,
        3111497, 3111497, 3111497, 3111497, 3111497, 3111497, 3111497, 3111497,
        2680103, 2680103, 2680103, 2680103, 2680103, 2680103, 2680103, 2680103,
        2680103, 2680103, 2680103, 2680103, 2680103, 2680103, 2680103, 2680103,

        2725464, 2725464, 2725464, 2725464, 2725464, 2725464, 2725464, 2725464,
        1024112, 1024112, 1024112, 1024112, 1024112, 1024112, 1024112, 1024112,
        -1079900, -1079900, -1079900, -1079900, -1079900, -1079900, -1079900, -1079900,
        3585928, 3585928, 3585928, 3585928, 3585928, 3585928, 3585928, 3585928,
        -549488, -549488, -549488, -549488, -549488, -549488, -549488, -549488,
        -1119584, -1119584, -1119584, -1119584, -1119584, -1119584, -1119584, -1119584,
        2619752, 2619752, 2619752, 2619752, 2619752, 2619752, 2619752, 2619752,
        -2108549, -2108549, -2108549, -2108549, -2108549, -2108549, -2108549, -2108549,
        -2118186, -2118186, -2118186, -2118186, -2118186, -2118186, -2118186, -2118186,
        -3859737, -3859737, -3859737, -3859737, -3859737, -3859737, -3859737, -3859737,
        -1399561, -1399561, -1399561, -1399561, -1399561, -1399561, -1399561, -1399561,
        -3277672, -3277672, -3277672, -3277672, -3277672, -3277672, -3277672, -3277672,
        1757237, 1757237, 1757237, 1757237, 1757237, 1757237, 1757237, 1757237,
        -19422, -19422, -19422, -19422, -19422, -19422, -19422, -19422,
        4010497, 4010497, 4010497, 4010497, 4010497, 4010497, 4010497, 4010497,
        280005, 280005, 280005, 280005, 280005, 280005, 280005, 280005,

        2706023, 2706023, 2706023, 2706023, 95776, 95776, 95776, 95776,
        3077325, 3077325, 3077325, 3077325, 3530437, 3530437, 3530437, 3530437,
        -1661693, -1661693, -1661693, -1661693, -3592148, -3592148, -3592148, -3592148,
        -2537516, -2537516, -2537516, -2537516, 3915439, 3915439, 3915439, 3915439,
        -3861115, -3861115, -3861115, -3861115, -3043716, -3043716, -3043716, -3043716,
        3574422, 3574422, 3574422, 3574422, -2867647, -2867647, -2867647, -2867647,
        3539968, 3539968, 3539968, 3539968, -300467, -300467, -300467, -300467,
        2348700, 2348700, 2348700, 2348700, -539299, -539299, -539299, -539299,
        -1699267, -1699267, -1699267, -1699267, -1643818, -1643818, -1643818, -1643818,
        3505694, 3505694, 3505694, 3505694, -3821735, -3821735, -3821735, -3821735,
        3507263, 3507263, 3507263, 3507263, -2140649, -2140649, -2140649, -2140649,
        -1600420, -1600420, -1600420, -1600420, 3699596, 3699596, 3699596, 3699596,
        811944, 811944, 811944, 811944, 531354, 531354, 531354, 531354,
        954230, 954230, 954230, 954230, 3881043, 3881043, 3881043, 3881043,
        3900724, 3900724, 3900724, 3900724, -2556880, -2556880, -2556880, -2556880,
        2071892, 2071892, 2071892, 2071892, -2797779, -2797779, -2797779, -2797779,

        -3930395, -3930395, -1528703, -1528703, -3677745, -3677745, -3041255, -3041255,
        -1452451, -1452451, 3475950, 3475950, 2176455, 2176455, -1585221, -1585221,
        -1257611, -1257611, 1939314, 1939314, -4083598, -4083598, -1000202, -1000202,
        -3190144, -3190144, -3157330, -3157330, -3632928, -3632928, 126922, 126922,
        3412210, 3412210, -983419, -983419, 2147896, 2147896, 2715295, 2715295,
        -2967645, -2967645, -3693493, -3693493, -411027, -411027, -2477047, -2477047,
        -671102, -671102, -1228525, -1228525, -22981, -22981, -1308169, -1308169,
        -381987, -381987, 1349076, 1349076, 1852771, 1852771, -1430430, -1430430,
        -3343383, -3343383, 264944, 264944, 508951, 508951, 3097992, 3097992,
        44288, 44288, -1100098, -1100098, 904516, 904516, 3958618, 3958618,
        -3724342, -3724342, -8578, -8578, 1653064, 1653064, -3249728, -3249728,
        2389356, 2389356, -210977, -210977, 759969, 759969, -1316856, -1316856,
        189548, 189548, -3553272, -3553272, 3159746, 3159746, -1851402, -1851402,
        -2409325, -2409325, -177440, -177440, 1315589, 1315589, 1341330, 1341330,
        1285669, 1285669, -1584928, -1584928, -812732, -812732, -1439742, -1439742,
        -3019102, -3019102, -3881060, -3881060, -3628969, -3628969, 3839961, 3839961,

        2091667, 3407706, 2316500, 3817976, -3342478, 2244091, -2446433, -3562462,
        266997, 2434439, -1235728, 3513181, -3520352, -3759364, -1197226, -3193378,
        900702, 1859098, 909542, 819034, 495491, -1613174, -43260, -522500,
        -655327, -3122442, 2031748, 3207046, -3556995, -525098, -768622, -3595838,
        342297, 286988, -2437823, 4108315, 3437287, -3342277, 1735879, 203044,
        2842341, 2691481, -2590150, 1265009, 4055324, 1247620, 2486353, 1595974,
        -3767016, 1250494, 2635921, -3548272, -2994039, 1869119, 1903435, -1050970,
        -1333058, 1237275, -3318210, -1430225, -451100, 1312455, 3306115, -1962642,
        -1279661, 1917081, -2546312, -1374803, 1500165, 777191, 2235880, 3406031,
        -542412, -2831860, -1671176, -1846953, -2584293, -3724270, 594136, -3776993,
        -2013608, 2432395, 2454455, -164721, 1957272, 3369112, 185531, -1207385,
        -3183426, 162844, 1616392, 3014001, 810149, 1652634, -3694233, -1799107,
        -3038916, 3523897, 3866901, 269760, 2213111, -975884, 1717735, 472078,
        -426683, 1723600, -1803090, 1910376, -1667432, -1104333, -260646, -3833893,
        -2939036, -2235985, -420899, -2286327, 183443, -976891, 1612842, -3545687,
        -554416, 3919660, -48306, -1362209, 3937738, 1400424, -846154, 1976782
    };

    private static final int[] montZetasForVectorInverseNtt = new int[]{
        -1976782, 846154, -1400424, -3937738, 1362209, 48306, -3919660, 554416,
        3545687, -1612842, 976891, -183443, 2286327, 420899, 2235985, 2939036,
        3833893, 260646, 1104333, 1667432, -1910376, 1803090, -1723600, 426683,
        -472078, -1717735, 975884, -2213111, -269760, -3866901, -3523897, 3038916,
        1799107, 3694233, -1652634, -810149, -3014001, -1616392, -162844, 3183426,
        1207385, -185531, -3369112, -1957272, 164721, -2454455, -2432395, 2013608,
        3776993, -594136, 3724270, 2584293, 1846953, 1671176, 2831860, 542412,
        -3406031, -2235880, -777191, -1500165, 1374803, 2546312, -1917081, 1279661,
        1962642, -3306115, -1312455, 451100, 1430225, 3318210, -1237275, 1333058,
        1050970, -1903435, -1869119, 2994039, 3548272, -2635921, -1250494, 3767016,
        -1595974, -2486353, -1247620, -4055324, -1265009, 2590150, -2691481, -2842341,
        -203044, -1735879, 3342277, -3437287, -4108315, 2437823, -286988, -342297,
        3595838, 768622, 525098, 3556995, -3207046, -2031748, 3122442, 655327,
        522500, 43260, 1613174, -495491, -819034, -909542, -1859098, -900702,
        3193378, 1197226, 3759364, 3520352, -3513181, 1235728, -2434439, -266997,
        3562462, 2446433, -2244091, 3342478, -3817976, -2316500, -3407706, -2091667,

        -3839961, -3839961, 3628969, 3628969, 3881060, 3881060, 3019102, 3019102,
        1439742, 1439742, 812732, 812732, 1584928, 1584928, -1285669, -1285669,
        -1341330, - 1341330, -1315589, -1315589, 177440, 177440, 2409325, 2409325,
        1851402, 1851402, -3159746, -3159746, 3553272, 3553272, -189548, -189548,
        1316856, 1316856, -759969, -759969, 210977, 210977, -2389356, -2389356,
        3249728, 3249728, -1653064, -1653064, 8578, 8578, 3724342, 3724342,
        -3958618, -3958618, -904516, -904516, 1100098, 1100098, -44288, -44288,
        -3097992, -3097992, -508951, -508951, -264944, -264944, 3343383, 3343383,
        1430430, 1430430, -1852771, -1852771, -1349076, -1349076, 381987, 381987,
        1308169, 1308169, 22981, 22981, 1228525, 1228525, 671102, 671102,
        2477047, 2477047, 411027, 411027, 3693493, 3693493, 2967645, 2967645,
        -2715295, -2715295, -2147896, -2147896, 983419, 983419, -3412210, -3412210,
        -126922, -126922, 3632928, 3632928, 3157330, 3157330, 3190144, 3190144,
        1000202, 1000202, 4083598, 4083598, -1939314, -1939314, 1257611, 1257611,
        1585221, 1585221, -2176455, -2176455, -3475950, -3475950, 1452451, 1452451,
        3041255, 3041255, 3677745, 3677745, 1528703, 1528703, 3930395, 3930395,

        2797779, 2797779, 2797779, 2797779, -2071892, -2071892, -2071892, -2071892,
        2556880, 2556880, 2556880, 2556880, -3900724, -3900724, -3900724, -3900724,
        -3881043, -3881043, -3881043, -3881043, -954230, -954230, -954230, -954230,
        -531354, -531354, -531354, -531354, -811944, -811944, -811944, -811944,
        -3699596, -3699596, -3699596, -3699596, 1600420, 1600420, 1600420, 1600420,
        2140649, 2140649, 2140649, 2140649, -3507263, -3507263, -3507263, -3507263,
        3821735, 3821735, 3821735, 3821735, -3505694, -3505694, -3505694, -3505694,
        1643818, 1643818, 1643818, 1643818, 1699267, 1699267, 1699267, 1699267,
        539299, 539299, 539299, 539299, -2348700, -2348700, -2348700, -2348700,
        300467, 300467, 300467, 300467, -3539968, -3539968, -3539968, -3539968,
        2867647, 2867647, 2867647, 2867647, -3574422, -3574422, -3574422, -3574422,
        3043716, 3043716, 3043716, 3043716, 3861115, 3861115, 3861115, 3861115,
        -3915439, -3915439, -3915439, -3915439, 2537516, 2537516, 2537516, 2537516,
        3592148, 3592148, 3592148, 3592148, 1661693, 1661693, 1661693, 1661693,
        -3530437, -3530437, -3530437, -3530437, -3077325, -3077325, -3077325, -3077325,
        -95776, -95776, -95776, -95776, -2706023, -2706023, -2706023, -2706023,

        -280005, -280005, -280005, -280005, -280005, -280005, -280005, -280005,
        -4010497, -4010497, -4010497, -4010497, -4010497, -4010497, -4010497, -4010497,
        19422, 19422, 19422, 19422, 19422, 19422, 19422, 19422,
        -1757237, -1757237, -1757237, -1757237, -1757237, -1757237, -1757237, -1757237,
        3277672, 3277672, 3277672, 3277672, 3277672, 3277672, 3277672, 3277672,
        1399561, 1399561, 1399561, 1399561, 1399561, 1399561, 1399561, 1399561,
        3859737, 3859737, 3859737, 3859737, 3859737, 3859737, 3859737, 3859737,
        2118186, 2118186, 2118186, 2118186, 2118186, 2118186, 2118186, 2118186,
        2108549, 2108549, 2108549, 2108549, 2108549, 2108549, 2108549, 2108549,
        -2619752, -2619752, -2619752, -2619752, -2619752, -2619752, -2619752, -2619752,
        1119584, 1119584, 1119584, 1119584, 1119584, 1119584, 1119584, 1119584,
        549488, 549488, 549488, 549488, 549488, 549488, 549488, 549488,
        -3585928, -3585928, -3585928, -3585928, -3585928, -3585928, -3585928, -3585928,
        1079900, 1079900, 1079900, 1079900, 1079900, 1079900, 1079900, 1079900,
        -1024112, -1024112, -1024112, -1024112, -1024112, -1024112, -1024112, -1024112,
        -2725464, -2725464, -2725464, -2725464, -2725464, -2725464, -2725464, -2725464,

        -2680103, -2680103, -2680103, -2680103, -2680103, -2680103, -2680103, -2680103,
        -2680103, -2680103, -2680103, -2680103, -2680103, -2680103, -2680103, -2680103,
        -3111497, -3111497, -3111497, -3111497, -3111497, -3111497, -3111497, -3111497,
        -3111497, -3111497, -3111497, -3111497, -3111497, -3111497, -3111497, -3111497,
        2884855, 2884855, 2884855, 2884855, 2884855, 2884855, 2884855, 2884855,
        2884855, 2884855, 2884855, 2884855, 2884855, 2884855, 2884855, 2884855,
        -3119733, -3119733, -3119733, -3119733, -3119733, -3119733, -3119733, -3119733,
        -3119733, -3119733, -3119733, -3119733, -3119733, -3119733, -3119733, -3119733,
        2091905, 2091905, 2091905, 2091905, 2091905, 2091905, 2091905, 2091905,
        2091905, 2091905, 2091905, 2091905, 2091905, 2091905, 2091905, 2091905,
        359251, 359251, 359251, 359251, 359251, 359251, 359251, 359251,
        359251, 359251, 359251, 359251, 359251, 359251, 359251, 359251,
        -2353451, -2353451, -2353451, -2353451, -2353451, -2353451, -2353451, -2353451,
        -2353451, -2353451, -2353451, -2353451, -2353451, -2353451, -2353451, -2353451,
        -1826347, -1826347, -1826347, -1826347, -1826347, -1826347, -1826347, -1826347,
        -1826347, -1826347, -1826347, -1826347, -1826347, -1826347, -1826347, -1826347,

        -466468, -466468, -466468, -466468, -466468, -466468, -466468, -466468,
        -466468, -466468, -466468, -466468, -466468, -466468, -466468, -466468,
        -466468, -466468, -466468, -466468, -466468, -466468, -466468, -466468,
        -466468, -466468, -466468, -466468, -466468, -466468, -466468, -466468,
        876248, 876248, 876248, 876248, 876248, 876248, 876248, 876248,
        876248, 876248, 876248, 876248, 876248, 876248, 876248, 876248,
        876248, 876248, 876248, 876248, 876248, 876248, 876248, 876248,
        876248, 876248, 876248, 876248, 876248, 876248, 876248, 876248,
        777960, 777960, 777960, 777960, 777960, 777960, 777960, 777960,
        777960, 777960, 777960, 777960, 777960, 777960, 777960, 777960,
        777960, 777960, 777960, 777960, 777960, 777960, 777960, 777960,
        777960, 777960, 777960, 777960, 777960, 777960, 777960, 777960,
        -237124, -237124, -237124, -237124, -237124, -237124, -237124, -237124,
        -237124, -237124, -237124, -237124, -237124, -237124, -237124, -237124,
        -237124, -237124, -237124, -237124, -237124, -237124, -237124, -237124,
        -237124, -237124, -237124, -237124, -237124, -237124, -237124, -237124,

        518909, 518909, 518909, 518909, 518909, 518909, 518909, 518909,
        518909, 518909, 518909, 518909, 518909, 518909, 518909, 518909,
        518909, 518909, 518909, 518909, 518909, 518909, 518909, 518909,
        518909, 518909, 518909, 518909, 518909, 518909, 518909, 518909,
        518909, 518909, 518909, 518909, 518909, 518909, 518909, 518909,
        518909, 518909, 518909, 518909, 518909, 518909, 518909, 518909,
        518909, 518909, 518909, 518909, 518909, 518909, 518909, 518909,
        518909, 518909, 518909, 518909, 518909, 518909, 518909, 518909,
        2608894, 2608894, 2608894, 2608894, 2608894, 2608894, 2608894, 2608894,
        2608894, 2608894, 2608894, 2608894, 2608894, 2608894, 2608894, 2608894,
        2608894, 2608894, 2608894, 2608894, 2608894, 2608894, 2608894, 2608894,
        2608894, 2608894, 2608894, 2608894, 2608894, 2608894, 2608894, 2608894,
        2608894, 2608894, 2608894, 2608894, 2608894, 2608894, 2608894, 2608894,
        2608894, 2608894, 2608894, 2608894, 2608894, 2608894, 2608894, 2608894,
        2608894, 2608894, 2608894, 2608894, 2608894, 2608894, 2608894, 2608894,
        2608894, 2608894, 2608894, 2608894, 2608894, 2608894, 2608894, 2608894,

        -25847, -25847, -25847, -25847, -25847, -25847, -25847, -25847,
        -25847, -25847, -25847, -25847, -25847, -25847, -25847, -25847,
        -25847, -25847, -25847, -25847, -25847, -25847, -25847, -25847,
        -25847, -25847, -25847, -25847, -25847, -25847, -25847, -25847,
        -25847, -25847, -25847, -25847, -25847, -25847, -25847, -25847,
        -25847, -25847, -25847, -25847, -25847, -25847, -25847, -25847,
        -25847, -25847, -25847, -25847, -25847, -25847, -25847, -25847,
        -25847, -25847, -25847, -25847, -25847, -25847, -25847, -25847,
        -25847, -25847, -25847, -25847, -25847, -25847, -25847, -25847,
        -25847, -25847, -25847, -25847, -25847, -25847, -25847, -25847,
        -25847, -25847, -25847, -25847, -25847, -25847, -25847, -25847,
        -25847, -25847, -25847, -25847, -25847, -25847, -25847, -25847,
        -25847, -25847, -25847, -25847, -25847, -25847, -25847, -25847,
        -25847, -25847, -25847, -25847, -25847, -25847, -25847, -25847,
        -25847, -25847, -25847, -25847, -25847, -25847, -25847, -25847,
        -25847, -25847, -25847, -25847, -25847, -25847, -25847, -25847
    };
    private final int dilithiumASeedLength = 32; //could change to dilithiumRhoLength
    private final int dilithiumS1S2SeedLength = 64;
    private final int dilithiumKLength = 32;
    private final int dilithiumTrLength = 64;
    private final int dilithiumMuLength = 64;
    private final int dilithiumMaskSeedLength = 64;
    private static final int dilithium_d = 13;
    private static final int dMask = (1 << dilithium_d) - 1;
    private final int tau;
    private final int lambda;
    private final int gamma1;
    private final int gamma1Bits;
    private final int gamma2;
    private final int dilithium_k;
    private final int dilithium_l;
    private final int eta;
    private final int beta;
    private final int omega;
    private final int s1PackedLength;
    private final int s2PackedLength;
    private final int s1s2CoeffSize;
    private final int t0CoeffSize = 13;
    private final int privateKeyLength;
    private final int publicKeyLength;
    private final int signatureLength;
    private final int wCoeffSize;
    private final int level;

    public Dilithium(int security_level) {
        switch (security_level) {
            case 2:
                level = 2;
                tau = 39;
                lambda = 128;
                gamma1 = 1 << 17;
                gamma1Bits = 17;
                gamma2 = (dilithium_q - 1) / 88;
                dilithium_k = 4;
                dilithium_l = 4;
                eta = 2;
                beta = 78;
                omega = 80;
                privateKeyLength = 0;
                publicKeyLength = 1312;
                signatureLength = 2420;
                s1PackedLength = 384;
                s2PackedLength = 384;
                s1s2CoeffSize = 3;
                wCoeffSize = 6;
                break;
            case 3:
                level = 3;
                tau = 49;
                lambda = 192;
                gamma1 = 1 << 19;
                gamma1Bits = 19;
                gamma2 = (dilithium_q - 1) / 32;
                dilithium_k = 6;
                dilithium_l = 5;
                eta = 4;
                beta = 196;
                omega = 55;
                privateKeyLength = 0;
                publicKeyLength = 1952;
                signatureLength = 3293;
                s1PackedLength = 640;
                s2PackedLength = 768;
                s1s2CoeffSize = 4;
                wCoeffSize = 4;
                break;
            case 5:
                level = 4;
                tau = 60;
                lambda = 256;
                gamma1 = 1 << 19;
                gamma1Bits = 19;
                gamma2 = (dilithium_q - 1) / 32;
                dilithium_k = 8;
                dilithium_l = 7;
                eta = 2;
                beta = 120;
                omega = 75;
                privateKeyLength = 0;
                publicKeyLength = 2592;
                signatureLength = 4595;
                s1PackedLength = 672;
                s2PackedLength = 768;
                s1s2CoeffSize = 3;
                wCoeffSize = 4;
                break;
            default:
                throw new IllegalArgumentException("Wrong security level");
        }
    }

    public record DilithiumPrivateKey(byte[] rho, byte[] k, byte[] tr, int[][] s1, int[][] s2, int[][] t0) {
    }

    public record DilithiumPublicKey(byte[] rho, int[][] t1) {
    }

    public record DilithiumKeyPair(DilithiumPrivateKey privateKey, DilithiumPublicKey publicKey) {
    }

    public record DilithiumSignature(byte[] commitmentHash, int[][] response, boolean[][] hint) {
    }

    public DilithiumKeyPair generateKeyPair(byte[] randomBytes) {
        //Initialize hash functions
        var dilithiumH = new SHAKE256(0);
        var dilithiumCRH = new SHAKE256(dilithiumTrLength);

        //Expand seed
        dilithiumH.update(randomBytes);
        dilithiumH.update((byte)dilithium_k);
        dilithiumH.update((byte)dilithium_l);
        byte[] rho = dilithiumH.squeeze(dilithiumASeedLength);
        byte[] rhoPrime = dilithiumH.squeeze(dilithiumS1S2SeedLength);
        byte[] k = dilithiumH.squeeze(dilithiumKLength);
        dilithiumH.reset();

        //Sample A
        int[][][] keygenA = generateA(rho); //A is in NTT domain

        //Sample S1 and S2
        int[][] s1 = new int[dilithium_l][dilithium_n];
        int[][] s2 = new int[dilithium_k][dilithium_n];
        sampleS1S2(s1, s2, dilithiumH, rhoPrime); //dilithiumH is reset before being used in sampleS1S2

        //Compute t and tr
        mlDsaVectorNtt(s1); //s1 now in NTT domain
        int[][] As1 = matrixVectorPointwiseMultiply(keygenA, s1);
        mlDsaVectorInverseNtt(s1); //take s1 out of NTT domain

        mlDsaVectorInverseNtt(As1);
        int[][] t = vectorAddPos(As1, s2);
        int[][] t0 = new int[dilithium_k][dilithium_n];
        int[][] t1 = new int[dilithium_k][dilithium_n];
        power2Round(t, t0, t1);

        //Encode PK and SK
        DilithiumPublicKey pk = new DilithiumPublicKey(rho, t1);
        byte[] publicKeyBytes = pkEncode(pk);
        dilithiumCRH.update(publicKeyBytes);
        byte[] tr = dilithiumCRH.digest();
        DilithiumPrivateKey sk = new DilithiumPrivateKey(rho, k, tr, s1, s2, t0);

        return new DilithiumKeyPair(sk, pk);
    }

    public DilithiumSignature sign(byte[] message, byte[] rnd, DilithiumPrivateKey sk) {
        //Initialize hash functions
        var dilithiumH = new SHAKE256(0);

        int[][] s1 = Arrays.stream(sk.s1()).map(int[]::clone).toArray(int[][]::new);
        int[][] s2 = Arrays.stream(sk.s2()).map(int[]::clone).toArray(int[][]::new);
        int[][] t0 = Arrays.stream(sk.t0()).map(int[]::clone).toArray(int[][]::new);

        //Do some NTTs
        mlDsaVectorNtt(s1);
        mlDsaVectorNtt(s2);
        mlDsaVectorNtt(t0);
        int[][][] aHat = generateA(sk.rho());

        //Compute mu
        dilithiumH.update(sk.tr());
        dilithiumH.update(message);
        byte[] mu = dilithiumH.squeeze(dilithiumMuLength);
        dilithiumH.reset();

        //Compute rho'
        dilithiumH.update(sk.k());
        dilithiumH.update(rnd);
        dilithiumH.update(mu);
        byte[] rhoPrime = dilithiumH.squeeze(dilithiumMaskSeedLength);
        dilithiumH.reset();

        //Initialize vectors used in loop
        int[][] z = null;
        boolean[][] h = null;
        byte[] commitmentHash = new byte[lambda/4];

        int kappa = 0;
        while (true) {
            int[][] y = expandMask(rhoPrime, kappa);

            //Compute w and w1
            mlDsaVectorNtt(y); //y is now in NTT domain
            int[][] w = matrixVectorPointwiseMultiply(aHat, y);
            mlDsaVectorInverseNtt(w); //w is not in normal domain
            int[][] w0 = new int[dilithium_k][dilithium_n];
            int[][] w1 = new int[dilithium_k][dilithium_n];
            decompose(w, w0, w1);
            mlDsaVectorInverseNtt(y); //todo: copy y instead of inverse NTTing

            //Get commitment hash
            dilithiumH.update(mu);
            dilithiumH.update(simpleBitPack(wCoeffSize, w1));
            commitmentHash = dilithiumH.squeeze(lambda/4);
            dilithiumH.reset();

            //Get z and r0
            int[] c = sampleInBall(commitmentHash);
            mlDsaNtt(c); //c is now in NTT domain
            int[][] cs1 = nttConstMultiply(c, s1); //todo: can make this one allocation before loop and modify nttConstMul
            int[][] cs2 = nttConstMultiply(c, s2);
            mlDsaVectorInverseNtt(cs1);
            mlDsaVectorInverseNtt(cs2);
            z = vectorAdd(y, cs1);
            int[][] r0 = vectorSub(w0, cs2);

            //Update z and h
            kappa += dilithium_l;
            if (vectorNormBound(z, gamma1 - beta) || vectorNormBound(r0, gamma2 - beta)) {
                continue;
            } else {
                int[][] ct0 = nttConstMultiply(c, t0);
                mlDsaVectorInverseNtt(ct0);
                h = makeHint(vectorConstMul(-1, ct0), vectorAdd(vectorAdd(w, vectorConstMul(-1, cs2)), ct0));
                if (vectorNormBound(ct0, gamma2) || (hammingWeight(h) > omega)) {
                    continue;
                }
            }
            return new DilithiumSignature(commitmentHash, z, h);
        }
    }

    public boolean verify(DilithiumPublicKey pk, byte[] message, DilithiumSignature sig) {
        var dilithiumH = new SHAKE256(0);

        //Check hint encoding
        if (sig.hint() == null) {return false;}

        //Expand A
        int[][][] aHat = generateA(pk.rho());

        //Generate tr
        dilithiumH.update(pkEncode(pk));
        byte[] tr = dilithiumH.squeeze(dilithiumTrLength);
        dilithiumH.reset();

        //Generate mu
        dilithiumH.update(tr);
        dilithiumH.update(message);
        byte[] mu = dilithiumH.squeeze(dilithiumMuLength);
        dilithiumH.reset();

        //Get verifiers challenge
        int[] cHat = sampleInBall(sig.commitmentHash());
        mlDsaNtt(cHat);

        //Deal with z
        int[][] z = Arrays.stream(sig.response()).map(int[]::clone).toArray(int[][]::new);
        boolean zNorm = vectorNormBound(z, gamma1 - beta);
        mlDsaVectorNtt(z);

        //Reconstruct signer's commitment
        int[][] aHatZ = matrixVectorPointwiseMultiply(aHat, z);
        int[][] t1Hat = vectorConstMul(1 << dilithium_d, pk.t1());
        mlDsaVectorNtt(t1Hat);
        int[][] wApprox = vectorSub(aHatZ,nttConstMultiply(cHat, t1Hat));
        mlDsaVectorInverseNtt(wApprox);
        int[][] w1Prime = useHint(sig.hint(), wApprox);

        //Hash signer's commitment
        dilithiumH.update(mu);
        dilithiumH.update(simpleBitPack(wCoeffSize, w1Prime));
        byte[] cTildePrime = dilithiumH.squeeze(lambda/4);

        //Check verify conditions
        boolean hashEq = Arrays.equals(sig.commitmentHash(), cTildePrime);
        boolean weight = hammingWeight(sig.hint()) <= omega;
        return !zNorm && hashEq && weight;
    }

    /*
    Data conversion functions in Section 8.1 of specification
     */

    // Bit-pack the t1 and w1 vector into a byte array.
    // The coefficients of the polynomials in the vector should be nonnegative and less than 2^bitsPerCoeff .
    //Todo: split this out into functions for each possible value of bitsPerCoeff
    public byte[] simpleBitPack(int bitsPerCoeff, int[][] vector) {
        byte[] result = new byte[(dilithium_k * dilithium_n * bitsPerCoeff) / 8];
        int acc = 0;
        int shift = 0;
        int i = 0;
        for (int[] poly : vector) {
            for (int m = 0; m < dilithium_n; m++) {
                acc += (poly[m] << shift);
                shift += bitsPerCoeff;
                while (shift >= 8) {
                    result[i++] = (byte) acc;
                    acc >>= 8;
                    shift -= 8;
                }
            }
        }
        return result;
    }

    public byte[] bitPack(int[][] vector, int bitsPerCoeff, int maxValue) {
        int vecLen = vector.length;
        byte[] result = new byte[(vecLen * dilithium_n * bitsPerCoeff) / 8];
        int acc = 0;
        int shift = 0;
        int i = 0;
        for (int[] poly : vector) {
            for (int m = 0; m < dilithium_n; m++) {
                acc += (maxValue - poly[m]) << shift;
                shift += bitsPerCoeff;
                while (shift >= 8) {
                    result[i++] = (byte) acc;
                    acc >>= 8;
                    shift -= 8;
                }
            }
        }
        return result;
    }

    public int[][] t1Unpack(byte[] v) {
        int[][] t1 = new int[dilithium_k][dilithium_n];
        for (int i = 0; i < dilithium_k; i++) {
            for (int j = 0; j < dilithium_n / 4; j++) {
                int tOffset = j*4;
                int vOffset = (i*320) + (j*5);
                t1[i][tOffset] = (v[vOffset] & 0xFF) + ((v[vOffset+1] << 8) & 0x3FF);
                t1[i][tOffset+1] = ((v[vOffset+1] >> 2) & 0x3F) + ((v[vOffset+2] << 6) & 0x3FF);
                t1[i][tOffset+2] = ((v[vOffset+2] >> 4) & 0xF) + ((v[vOffset+3] << 4) & 0x3FF);
                t1[i][tOffset+3] = ((v[vOffset+3] >> 6) & 0x3) + ((v[vOffset+4] << 2) & 0x3FF);
            }
        }
        return t1;
    }

    //Todo: look into breaking this out into separate functions as well
    public int[][] bitUnpack(byte[] v, int dim, int maxValue, int bitsPerCoeff) {
        int[][] res = new int[dim][dilithium_n];

        int mask = (1 << bitsPerCoeff) - 1;
        int top = 0;
        int shift = 0;
        int acc = 0;
        int index = 0;
        for (int i = 0; i < dim; i++) {
            for (int j = 0; j < dilithium_n; j++) {
                while (top - shift < bitsPerCoeff) {
                    acc += ((v[index++] & 0xff) << top);
                    top += 8;
                }
                res[i][j] = maxValue - ((acc >> shift) & mask);
                shift += bitsPerCoeff;
                while (shift >= 8) {
                    top -= 8;
                    shift -= 8;
                    acc >>>= 8;
                }
            }
        }
        return res;
    }

    private byte[] hintBitPack(boolean[][] h) {
        byte[] y = new byte[omega + dilithium_k];
        int idx = 0;
        for (int i = 0; i < dilithium_k; i++) {
            for (int j = 0; j < dilithium_n; j++) {
                if (h[i][j]) {
                    y[idx] = (byte)j;
                    idx++;
                }
            }
            y[omega + i] = (byte)idx;
        }
        return y;
    }

    private boolean[][] hintBitUnpack(byte[] y) {
        boolean[][] h = new boolean[dilithium_k][dilithium_n];
        int idx = 0;
        for (int i = 0; i < dilithium_k; i++) {
            int j = y[omega + i];
            if (j < idx || j > omega) {
                return null; //todo: throw an exception
            }
            while (idx < j) {
                int hintIndex = y[idx] & 0xff;
                h[i][hintIndex] = true;
                idx++;
            }
        }

        while (idx < omega) {
            if (y[idx] != 0) {
                return null; //todo: throw an exception
            }
            idx++;
        }
        return h;
    }

    /*
    Encoding functions as specified in Section 8.2 of the specification
     */

    public byte[] pkEncode(DilithiumPublicKey key) {
        byte[] t1Packed = simpleBitPack(10, key.t1);
        byte[] publicKeyBytes = new byte[dilithiumASeedLength + t1Packed.length];
        System.arraycopy(key.rho, 0, publicKeyBytes, 0, dilithiumASeedLength);
        System.arraycopy(t1Packed, 0, publicKeyBytes, dilithiumASeedLength, t1Packed.length);

        return publicKeyBytes;
    }

    public DilithiumPublicKey pkDecode(byte[] pk) {
        byte[] rho = new byte[dilithiumASeedLength];
        System.arraycopy(pk, 0, rho, 0, dilithiumASeedLength);

        byte[] v = Arrays.copyOfRange(pk, dilithiumASeedLength, pk.length);
        int[][] t1 = t1Unpack(v);
        return new DilithiumPublicKey(rho, t1);
    }

    public byte[] skEncode(DilithiumPrivateKey key) {

        byte[] s1Packed = bitPack(key.s1, s1s2CoeffSize, eta);
        byte[] s2Packed = bitPack(key.s2, s1s2CoeffSize, eta);
        byte[] t0Packed = bitPack(key.t0, t0CoeffSize, 1 << 12);

        byte[] skBytes = new byte[dilithiumASeedLength + dilithiumKLength + key.tr.length +
            s1PackedLength + s2PackedLength + t0Packed.length];

        System.arraycopy(key.rho, 0, skBytes, 0, dilithiumASeedLength);
        System.arraycopy(key.k, 0, skBytes, dilithiumASeedLength, dilithiumKLength);
        System.arraycopy(key.tr, 0, skBytes, dilithiumASeedLength + dilithiumKLength, dilithiumTrLength);
        System.arraycopy(s1Packed, 0, skBytes, dilithiumASeedLength + dilithiumKLength + key.tr.length, s1PackedLength);
        System.arraycopy(s2Packed, 0, skBytes, dilithiumASeedLength + dilithiumKLength + key.tr.length + s1PackedLength, s2PackedLength);
        System.arraycopy(t0Packed, 0, skBytes, dilithiumASeedLength + dilithiumKLength + key.tr.length + s1PackedLength + s2PackedLength, t0Packed.length);

        return skBytes;
    }

    public DilithiumPrivateKey skDecode(byte[] sk) {
        byte[] rho = new byte[dilithiumASeedLength];
        System.arraycopy(sk, 0, rho, 0, dilithiumASeedLength);

        byte[] k = new byte[dilithiumKLength];
        System.arraycopy(sk, dilithiumASeedLength, k, 0, dilithiumKLength);

        byte[] tr = new byte[dilithiumTrLength];
        System.arraycopy(sk, dilithiumASeedLength + dilithiumKLength, tr, 0, dilithiumTrLength);

        //Parse s1
        int start = dilithiumASeedLength + dilithiumKLength + dilithiumTrLength;
        int end = start + (32 * dilithium_l * s1s2CoeffSize);
        byte[] y = Arrays.copyOfRange(sk, start, end);
        int[][] s1 = bitUnpack(y, dilithium_l, eta, s1s2CoeffSize);

        //Parse s2
        start = end;
        end += 32 * s1s2CoeffSize * dilithium_k;
        byte[] z = Arrays.copyOfRange(sk, start, end);
        int[][] s2 = bitUnpack(z, dilithium_k, eta, s1s2CoeffSize);

        //Parse t0
        start = end;
        end += 32 * dilithium_d * dilithium_k;
        byte[] w = Arrays.copyOfRange(sk, start, end);
        int[][] t0 = bitUnpack(w, dilithium_k, 1 << 12, t0CoeffSize);

        return new DilithiumPrivateKey(rho, k, tr, s1, s2, t0);
    }

    public byte[] sigEncode(DilithiumSignature sig) {
        int cSize = lambda / 4;
        int zSize = dilithium_l * 32 * (1 + gamma1Bits);

        byte[] zPacked = bitPack(sig.response, gamma1Bits + 1, gamma1);
        byte[] hPacked = hintBitPack(sig.hint);

        byte[] sigBytes = new byte[cSize + zSize + omega + dilithium_k];
        System.arraycopy(sig.commitmentHash, 0, sigBytes, 0, cSize);
        System.arraycopy(zPacked, 0, sigBytes, cSize, zSize);
        System.arraycopy(hPacked, 0, sigBytes, cSize + zSize, omega + dilithium_k);
        return sigBytes;
    }

    public DilithiumSignature sigDecode(byte[] sig) {
        //Decode cTilde
        byte[] cTilde = Arrays.copyOfRange(sig, 0, lambda/4);

        //Decode z
        int start = lambda / 4;
        int end = start + (32 * dilithium_l * (1 + gamma1Bits));
        byte[] x = Arrays.copyOfRange(sig, start, end);
        int[][] z = bitUnpack(x, dilithium_l, gamma1, gamma1Bits + 1);

        //Decode h
        start = end;
        end += omega + dilithium_k;
        byte[] y = Arrays.copyOfRange(sig, start, end);
        boolean[][] h = hintBitUnpack(y);
        return new DilithiumSignature(cTilde, z, h);
    }

    /*
    Auxiliary functions defined in Section 8.3 of specification
     */

    private class Shake256Slicer {
        SHAKE256 xof;
        byte[] block;
        int byteOffset;
        int current;
        int bitsInCurrent;
        int bitsPerCall;
        int bitMask;

        Shake256Slicer(SHAKE256 xof, int bitsPerCall) {
            this.xof = xof;
            this.bitsPerCall = bitsPerCall;
            bitMask = (1 << bitsPerCall) - 1;
            current = 0;
            byteOffset = shake256BlockSize;
            bitsInCurrent = 0;
            block = new byte[shake256BlockSize];
        }

        void reset() {
            xof.reset();
            current = 0;
            byteOffset = shake256BlockSize;
            bitsInCurrent = 0;
        }

        int squeezeBits() {
            while (bitsInCurrent < bitsPerCall) {
                if (byteOffset == shake256BlockSize) {
                    xof.squeeze(block, 0, shake256BlockSize);
                    byteOffset = 0;
                }
                current += ((block[byteOffset++] & 0xff) << bitsInCurrent);
                bitsInCurrent += 8;
            }
            int result = current & bitMask;
            current >>= bitsPerCall;
            bitsInCurrent -= bitsPerCall;
            return result;
        }
    }

    private int[] sampleInBall(byte[] rho) {
        var xof = new SHAKE256(0);
        Shake256Slicer slicer = new Shake256Slicer(xof, 8);
        xof.update(rho);

        long parity = 0;
        for (int i = 0; i < 8; i++) {
            long sample = slicer.squeezeBits();
            parity |= sample << 8 * i;
        }

        int[] c = new int[dilithium_n];
        int k = 8;
        for (int i = 256 - tau; i < 256; i++) {
            //Get random index < i
            int j = slicer.squeezeBits();
            while (j > i) {
                j = slicer.squeezeBits();
            }

            //Swap c[i] and c[j], set c[j] based on parity
            c[i] = c[j];
            c[j] = (int) (1 - 2 * (parity & 1));
            parity >>= 1;
        }
        return c;
    }

    private void sampleS1S2(int[][] s1, int[][] s2, SHAKE256 xof, byte[] rhoPrime) {
        byte[] seed = new byte[dilithiumS1S2SeedLength + 2];
        System.arraycopy(rhoPrime, 0, seed, 0, dilithiumS1S2SeedLength);

        int bitsPerCall = 4;
        Shake256Slicer slicer = new Shake256Slicer(xof, bitsPerCall);
        for (int i = 0; i < dilithium_l; i++) {
            seed[dilithiumS1S2SeedLength] = (byte) i;
            seed[dilithiumS1S2SeedLength + 1] = 0;
            slicer.reset();
            xof.update(seed);
            if (eta == 2) {
                for (int j = 0; j < dilithium_n; j++) {
                    int sample;
                    do {
                        sample = slicer.squeezeBits();
                    } while (sample > 14);
                    s1[i][j] = eta - sample + (205 * sample >> 10) * 5; // 2 - sample mod 5
                }
            } else { // eta == 4
                for (int j = 0; j < dilithium_n; j++) {
                    int sample;
                    do {
                        sample = slicer.squeezeBits();
                    } while (sample > 2 * eta);
                    s1[i][j] = eta - sample;
                }
            }
        }
        for (int i = 0; i < dilithium_k; i++) {
            seed[dilithiumS1S2SeedLength] = (byte) (dilithium_l + i);
            seed[dilithiumS1S2SeedLength + 1] = 0;
            slicer.reset();
            xof.update(seed);
            if (eta == 2) {
                for (int j = 0; j < dilithium_n; j++) {
                    int sample;
                    do {
                        sample = slicer.squeezeBits();
                    } while (sample > 14);
                    s2[i][j] = eta - sample + (205 * sample >> 10) * 5;
                }
            } else {
                for (int j = 0; j < dilithium_n; j++) {
                    int sample;
                    do {
                        sample = slicer.squeezeBits();
                    } while (sample > 2 * eta);
                    s2[i][j] = eta - sample;
                }
            }
        }
    }

    int[][][] generateA(byte[] seed) {
        int blockSize = 168;  // the size of one block of SHAKE128 output
        var xof = new SHAKE128(0);
        byte[] xofSeed = new byte[dilithiumASeedLength + 2];
        System.arraycopy(seed, 0, xofSeed, 0, dilithiumASeedLength);
        int[][][] a = new int[dilithium_k][dilithium_l][dilithium_n];

        for (int i = 0; i < dilithium_k; i++) {
            for (int j = 0; j < dilithium_l; j++) {
                xofSeed[dilithiumASeedLength] = (byte) j;
                xofSeed[dilithiumASeedLength + 1] = (byte) i;
                xof.reset();
                xof.update(xofSeed);

                byte[] rawAij = new byte[blockSize];
                int[] aij = new int[dilithium_n];
                int ofs = 0;
                int rawOfs = blockSize;
                int tmp;
                while (ofs < dilithium_n) {
                    if (rawOfs == blockSize) {  // works because 3 divides blockSize (=168)
                        xof.squeeze(rawAij, 0, blockSize);
                        rawOfs = 0;
                    }
                    tmp = (rawAij[rawOfs] & 0xFF) +
                        ((rawAij[rawOfs + 1] & 0xFF) << 8) +
                        ((rawAij[rawOfs + 2] & 0x7F) << 16);
                    rawOfs += 3;
                    if (tmp < dilithium_q) {
                        aij[ofs] = tmp;
                        ofs++;
                    }
                }
                a[i][j] = aij;
            }
        }
        return a;
    }

    private int[][] expandMask(byte[] rho, int mu) {
        var xof = new SHAKE256(0);

        int[][] res = new int[dilithium_l][dilithium_n];
        int c = 1 + gamma1Bits;
        byte[] v = new byte[dilithium_l * 32 * c];
        for (int r = 0; r < dilithium_l; r++) {
            int a = mu + r;
            byte[] n = {(byte) a, (byte) (a >> 8)};

            xof.update(rho);
            xof.update(n);
            for (int i = 0; i < 32*c; i++) {
                v[r*32*c + i] = xof.squeeze(1)[0];
            }
            xof.reset();
        }
        return bitUnpack(v, dilithium_l, gamma1, c);
    }

    /*
    Auxiliary functions defined in section 8.4 of specification
     */

    private void power2Round(int[][] input, int[][] lowPart, int[][] highPart) {
        for (int i = 0; i < dilithium_k; i++) {
            for (int m = 0; m < dilithium_n; m++) {
                int rplus = input[i][m];
                int r0 = input[i][m] & dMask;
                int r00 = (1 << (dilithium_d - 1)) - r0 ; // 2^d/2 - r+
                r0 -= (r00 >> 31) & (1 << dilithium_d); //0 if r+ < 2^d/2
                lowPart[i][m] = r0;
                highPart[i][m] = (rplus - r0) >> dilithium_d;
            }
        }
    }

    private void decompose(int[][] input, int[][] lowPart, int[][] highPart) {
        for (int i = 0; i < dilithium_k; i++) {
            for (int m = 0; m < dilithium_n; m++) {
                int rplus = (input[i][m] + dilithium_q) % dilithium_q;
                int r0 = rplus % (2*gamma2);
                r0 -= r0 > gamma2 ? 2*gamma2 : 0;
                int r1;
                if (rplus - r0 == dilithium_q - 1) {
                    r1 = 0;
                    r0 = r0 - 1;
                } else {
                    r1 = (rplus - r0) / (2*gamma2);
                }
                lowPart[i][m] = r0;
                highPart[i][m] = r1;
            }
        }
    }

    private int highBits(int input) {
        int rplus = (input + dilithium_q) % dilithium_q;
        int r0 = rplus % (2*gamma2);
        r0 -= r0 > gamma2 ? 2*gamma2 : 0;
        int r1;
        if (rplus - r0 == dilithium_q - 1) {
            r1 = 0;
            r0 = r0 - 1;
        } else {
            r1 = (rplus - r0) / (2*gamma2);
        }
        return r1;
    }

    private boolean[][] makeHint(int[][] z, int[][] r) {
        int[][] v1 = vectorAdd(r,z);
        boolean[][] res = new boolean[dilithium_k][dilithium_n];
        for (int i = 0; i < dilithium_k; i++) {
            for (int j = 0; j < dilithium_n; j++) {
                int r1High = highBits(r[i][j]);
                int v1High = highBits(v1[i][j]);
                res[i][j] = r1High != v1High;
            }
        }
        return res;
    }

    private int[][] useHint(boolean[][] h, int[][] r) {
        int m = (dilithium_q - 1) / (2*gamma2);
        int[][] lowPart = new int[dilithium_k][dilithium_n];
        int[][] highPart = new int[dilithium_k][dilithium_n];
        decompose(r, lowPart, highPart);

        for (int i = 0; i < dilithium_k; i++) {
            for (int j = 0; j < dilithium_n; j++) {
                if (h[i][j]) {
                    highPart[i][j] += lowPart[i][j] > 0 ? 1 : -1;
                }
                highPart[i][j] = ((highPart[i][j] % m) + m) % m;
            }
        }
        return highPart;
    }

    /*
    NTT functions as specified in Section 8.5 of specification
    */

    public static int[] mlDsaNtt(int[] coeffs) {
        int result = implDilithiumAlmostNtt(coeffs, montZetasForVectorNtt);
//        int result = implDilithiumAlmostNttJava(coeffs);
        int[] check = coeffs.clone();
        result = implDilithiumMontMulByConstant(coeffs,  montRModQ);
//        if (result == 0) {
//            implDilithiumMontMulByConstantJava(check, montRModQ);
//            if (!Arrays.equals(check, coeffs)) {
//                ML_KEM.TestUtils.printHex("check  = ", check);
//                ML_KEM.TestUtils.printHex("coeffs = ", coeffs);
//                throw new RuntimeException("check and coeffs differ");
//            }
//        }
        return coeffs;
    }

    @IntrinsicCandidate
    static int implDilithiumAlmostNtt(int[] coeffs, int[] zetas) {
        return implDilithiumAlmostNttJava(coeffs);
    }

    static int implDilithiumAlmostNttJava(int[] coeffs) {
        int dimension = dilithium_n;
        int m = 0;
        for (int l = dimension / 2; l > 0; l /= 2) {
            for (int s = 0; s < dimension; s += 2 * l) {
                for (int j = s; j < s + l; j++) {
                    int tmp = montMul(montZetasForNtt[m], coeffs[j + l]);
                    coeffs[j + l] = coeffs[j] - tmp;
                    coeffs[j] = coeffs[j] + tmp;
                }
                m++;
            }
        }

        return 1;
    }

    public static int[] mlDsaInverseNtt(int[] coeffs) {
        int result = implDilithiumAlmostInverseNtt(coeffs, montZetasForVectorInverseNtt);
//        int result = implDilithiumAlmostInverseNttJava(coeffs);
        result = implDilithiumMontMulByConstant(coeffs, montDimInverse);
        return coeffs;
    }

    @IntrinsicCandidate
    static int implDilithiumAlmostInverseNtt(int[] coeffs, int[] zetas) {
        return implDilithiumAlmostInverseNttJava(coeffs);
    }

    static int implDilithiumAlmostInverseNttJava(int[] coeffs) {
        int dimension = dilithium_n;
        int m = 0;
        for (int l = 1; l < dimension; l *= 2) {
            for (int s = 0; s < dimension; s += 2 * l) {
                for (int j = s; j < s + l; j++) {
                    int tmp = coeffs[j];
                    coeffs[j] = (tmp + coeffs[j + l]);
                    coeffs[j + l] = montMul(tmp - coeffs[j + l], montZetasForInverseNtt[m]);
                }
                m++;
            }
        }

        return 1;
    }

    void mlDsaVectorNtt(int[][] vector) {
        for (int[] ints : vector) {
            mlDsaNtt(ints);
        }
    }

    void mlDsaVectorInverseNtt(int[][] vector) {
        for (int[] ints : vector) {
            mlDsaInverseNtt(ints);
        }
    }

    public static int[] mlDsaNttMultiply(int[] coeffs1, int[] coeffs2) {
        int[] product = new int[dilithium_n];
        int result = implDilithiumNttMult(product, coeffs1, coeffs2);
        return product;
    }

    @IntrinsicCandidate
    static int implDilithiumNttMult(int[] product, int[] coeffs1, int[] coeffs2) {
        return implDilithiumNttMultJava(product, coeffs1, coeffs2);
    }

    static int implDilithiumNttMultJava(int[] product, int[] coeffs1, int[] coeffs2) {
        for (int i = 0; i < dilithium_n; i++) {
            product[i] = montMul(coeffs1[i], toMont(coeffs2[i]));
        }
        return 1;
    }

    public static void montMulByConstant(int[] coeffs, int constant) {
        int[] check = coeffs.clone();
        int result = implDilithiumMontMulByConstant(coeffs, constant);
    }

    @IntrinsicCandidate
    static int implDilithiumMontMulByConstant(int[] coeffs, int constant) {
        return implDilithiumMontMulByConstantJava(coeffs, constant);
    }

    static int implDilithiumMontMulByConstantJava(int[] coeffs, int constant) {
        for (int i = 0; i < dilithium_n; i++) {
            coeffs[i] = montMul((coeffs[i]), constant);
        }
        return 1;
    }

    public static int mlDsaDecomposePoly(int[] input, int[] lowPart, int[] highPart,
                                         int twoGamma2, int multiplier) {
        return implDilithiumDecomposePoly(input, lowPart, highPart,
            twoGamma2, multiplier);
    }

    @IntrinsicCandidate
    static int implDilithiumDecomposePoly(int[] input, int[] lowPart, int[] highPart,
                                          int twoGamma2, int multiplier) {
        return decomposePolyJava(input, lowPart, highPart, twoGamma2, multiplier);
    }

    static int decomposePolyJava(int[] input, int[] lowPart, int[] highPart,
                                 int twoGamma2, int multiplier) {
        for (int m = 0; m < dilithium_n; m++) {
            int rplus = input[m];
            rplus = rplus - ((rplus + 5373807) >> 23) * dilithium_q;
            rplus = rplus + ((rplus >> 31) & dilithium_q);
            int r0 = rplus - ((rplus * multiplier) >> 22) * twoGamma2;
            r0 -= (((twoGamma2 - r0) >> 22) & twoGamma2);
            r0 -= (((twoGamma2 / 2 - r0) >> 31) & twoGamma2);
            int r1 = rplus - r0 - (dilithium_q - 1);
            r1 = (r1 | (-r1)) >> 31;
            r0 += ~r1;
            r1 = r1 & ((rplus - r0) / twoGamma2);
            lowPart[m] = r0;
            highPart[m] = r1;
        }
        return 1;
    }

    private int[][] matrixVectorPointwiseMultiply(int[][][] matrix, int[][] vector) {
        int[][] result = new int[dilithium_k][dilithium_n];
        int resulti[] = new int[dilithium_n];
        for (int i = 0; i < dilithium_k; i++) {
            for (int m = 0; m < dilithium_n; m++) {
                resulti[m] = 0;
            }
            for (int j = 0; j < dilithium_l; j++) {
                int[] product = mlDsaNttMultiply(matrix[i][j], vector[j]);
                for (int m = 0; m < dilithium_n; m++) {
                    resulti[m] += product[m];
                }
            }
            for (int m = 0; m < dilithium_n; m++) {
                result[i][m] = montMul(resulti[m], montRModQ);
            }
        }
        return result;
    }

    private int[][] nttConstMultiply(int[] a, int[][] b) {
        int[][] res = new int[b.length][dilithium_n];
        for (int i = 0; i < b.length; i++) {
            res[i] = mlDsaNttMultiply(a, b[i]);
        }
        return res;
    }

    private int[][] vectorConstMul(int c, int[][] vec) {
        int[][] res = new int[vec.length][vec[0].length];
        for (int i = 0; i < vec.length; i++) {
            for (int j = 0; j < vec[0].length; j++) {
                res[i][j] = (c * vec[i][j]) % dilithium_q;
            }
        }
        return res;
    }

    // Adds two vectors of polynomials
    // The coefficients in the input should be between -montQ and montQ .
    // The coefficients in the output will be nonnegative and less than montQ
    int[][] vectorAddPos(int[][] vec1, int[][] vec2) {
        int dim = vec1.length;
        int[][] result = new int[dim][dilithium_n];
        for (int i = 0; i < dim; i++) {
            for (int m = 0; m < dilithium_n; m++) {
                int r = vec1[i][m] + vec2[i][m]; // -2 * montQ < r < 2 * montQ
                r += (((r >> 31) & (2 * montQ)) - montQ); // -montQ < r < montQ
                r += ((r >> 31) & montQ); // 0 <= r < montQ
                result[i][m] = r;
            }
        }
        return result;
    }

    int[][] vectorAdd(int[][] vec1, int[][] vec2) {
        int dim = vec1.length;
        int[][] result = new int[dim][dilithium_n];
        for (int i = 0; i < dim; i++) {
            for (int j = 0; j < dilithium_n; j++) {
                int tmp = vec1[i][j] + vec2[i][j];
                tmp -= tmp >= dilithium_q ? dilithium_q : 0;
                result[i][j] = tmp;
            }
        }
        return result;
    }

    int[][] vectorSub(int[][] vec1, int[][] vec2) {
        int dim = vec1.length;
        int[][] result = new int[dim][dilithium_n];
        for (int i = 0; i < dim; i++) {
            for (int j = 0; j < dilithium_n; j++) {
                int tmp = vec1[i][j] - vec2[i][j];
                tmp += tmp < 0 ? dilithium_q : 0;
                result[i][j] = tmp;
            }
        }
        return result;
    }

    //Precondition: 2^-31 <= r1 <= 2^31 - 5 * 2^20, and bound < q - 5234431
    //Computes whether the infinity norm of a vector is >= bound
    boolean vectorNormBound(int[][] vec, int bound) {
        boolean res = false;
        for (int i = 0; i < vec.length; i++) {
            for (int j = 0; j < dilithium_n; j++) {
                int r1 = vec[i][j];
                r1 = r1 - ((r1 + (5  << 20)) >> 23) * dilithium_q;
                r1 = r1 - ((r1 >> 31) & r1) * 2;
                res |= (r1 >= bound);
            }
        }
        return res;
    }

    private int hammingWeight(boolean[][] vec) {
        int weight = 0;
        for (int i = 0; i < dilithium_k; i++) {
            for (int j = 0; j < dilithium_n; j++) {
                weight += vec[i][j] ? 1 : 0;
            }
        }
        return weight;
    }

    // precondition: -2^31 * montQ <= a, b < 2^31, -2^31 < a * b < 2^31 * montQ
    // computes a * b * 2^-32 mod montQ
    // the result is greater than -montQ and less than montQ
    private static int montMul(int b, int c) {
        long a = (long) b * (long) c;
        int aHigh = (int) (a >> montRBits);
        int aLow = (int) a;
        int m = montQInvModR * aLow; // signed low product

        return (aHigh - (int) (((long)m * montQ) >> montRBits));  // subtract signed high product
    }

    static int toMont(int a) {
        return montMul(a, montRSquareModQ);
    }
}
